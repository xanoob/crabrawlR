#' Set rownames as taxa names, colnames as genefam names.
#' For get_homologues generated pangenome matrices.
#' @param dataframe of matrix imported using read.csv
#' @return dataframe with rownames as taxa names, colnames as genefam names
#' @keywords pangenome, matrix
#' @export 
#' @examples
#' panpretty(pangenomeMatrix)

panpretty = function(df) {
  df[,1] = gsub("\\.\\w+.fa*", "", df[,1])
  colnames(df) = df[1,]
  df = df[2:nrow(df),] # 'removes' row 1
  rnames = df[,1]
  df = df[,2:ncol(df)] # 'removes' col 1
  df = as.data.frame(sapply(df, as.numeric))
  rownames(df) = rnames
  return(df) 
}

#' Remove columns with NAs and return 'clean' matrix.
#' For get_homologues generated pangenome matrices.
#' @param dataframe generated by panpretty()
#' @return clean dataframe with no NAs
#' @keywords pangenome, matrix, removeNA
#' @export 
#' @examples
#' NAcheck(pangenomeMatrix)

NAcheck = function(df) {
  if(any(is.na(df))) {
    print("NA's found!")
    print(which(colSums(is.na(df)) > 0))
    clean=df[,which(colSums(is.na(df)) == 0)]
  }
  else {
    print("No NAs found.")
    clean=df[,which(colSums(is.na(df)) == 0)]
  }
  return(clean)
}

#' Soft core taxa value threshold--95\% from Kaas et al 2012
#' Up to what \% of taxa can have this gene absent to qualify for 'soft-core' definition?.
#' Returned int is \# of taxa that can have zeros in column (gene family) to qualify as 'soft-core'.
#' @param vector with taxa names or taxa row nums
#' @return numeric int, max # of taxa that can have genes missing
#' @keywords pangenome, matrix
#' @export 
#' @examples
#' softnum(PangenomeMatrix[,1])

softnum = function(taxct) {
  if(length(taxct) <= 20) {
    softN = 1 # only allowed to be absent in 1 taxon
  }
  else {
    softN = floor(length(taxct)*0.05) # allowed to have 0's in at least 5% of taxa rounded down to nearest int
  }
  return(softN)
}

#' Shell lower bound value from Van Vliet 2017 (15% of taxa)
#' Returned int is max \# of taxa that can have zeros in column (gene family) to qualify as 'shell'
#' @param vector with taxa names or taxa row nums
#' @return numeric int, max # of taxa that can have genes missing
#' @keywords pangenome, matrix
#' @export 
#' @examples
#' shellnum(PangenomeMatrix[,1])

shellnum = function(taxct) {
  shellN = floor(length(taxct)*.85) # allowed to have 0's in at most 85% of taxa
  return(shellN)
}

#' Given a list of taxa names (that are also rownames), get rownumbers
#' @param dataframe formatted by panpretty and NAcheck
#' @param vector of rownames for list of taxa to include (optional, default value NULL)
#' @param vector of rownames for list of taxa to exclude (optional, default value NULL)
#' @return list with rownumbers for taxa to include ($r_yes) or exclude ($r_no)
#' @keywords rownums, rownames
#' @export 
#' @examples
#' taxrownums(df=myPangenomeMatrix, taxa_yes=taxa_yes, taxa_no=taxa_no)

taxrownums = function(df=df, taxa_yes=NULL, taxa_no=NULL) {
  if(!(is.null(taxa_yes)) && !(is.null(taxa_no))) {
    taxaList = list(r_yes = match(taxa_yes, rownames(df)),
                    r_no = match(taxa_no, rownames(df)))
  }
  
  if(is.null(taxa_yes)) { # if user did not provide list of 'yes' taxa
    r_not= match(taxa_no, rownames(df))
    taxaList = list(r_no= r_not,
                    r_yes= which(!seq(1:length(df[,1])) %in% r_not)) }
  
  if(is.null(taxa_no)) { # if user did not provide list of 'no' taxa
    r_y= match(taxa_yes, rownames(df))
    taxaList = list(r_yes= r_y,
                    r_no = which(!seq(1:length(df[,1])) %in% r_y)) }
  
  
  return(taxaList)
}

#' Find shared gene families between a list of taxa
#' @param dataframe formatted by panpretty and NAcheck
#' @param vector of row numbers for list of taxa to include
#' @return numeric int, max # of taxa that can have genes missing
#' @keywords pangenome, matrix, shared, specific, unique
#' @export 
#' @examples
#' sharedgroups(pangenomeMatrix_clean, tax_yes)

sharedgroups = function(df, r_yes) {
  softN = softnum(r_yes)
  shellN = shellnum(r_yes)
  sharedG = list(yes_strict = which(colSums(df[r_yes,] == 0) == 0), 
                 yes_strict_ct = length(which(colSums(df[r_yes,] == 0) == 0)),
                 yes_soft = which(colSums(df[r_yes,] == 0) <= softN),
                 yes_soft_ct = length(which(colSums(df[r_yes,] == 0) <= softN)),
                 yes_shell = which(colSums(df[r_yes,] == 0) > softN & colSums(df[r_yes,] == 0) <= shellN),
                 yes_shell_ct = length(which(colSums(df[r_yes,] == 0) > softN & colSums(df[r_yes,] == 0) <= shellN)),
                 yes_cloud = which(colSums(df[r_yes,] == 0) > shellN & colSums(df[r_yes,] == 0) <= (length(r_yes) - 1)),
                 yes_cloud_ct = length(which(colSums(df[r_yes,] == 0) > shellN & colSums(df[r_yes,] == 0) <= (length(r_yes) - 1))),
                 yes_atleastone = which(colSums(df[r_yes,] == 0) < length(r_yes)),
                 yes_atleastone_ct = length(which(colSums(df[r_yes,] == 0) < length(r_yes)))
  )
  return(sharedG)
}


#' Find gene families present ONLY IN (unique to) a list of taxa
#' @param dataframe formatted by panpretty and NAcheck
#' @param vector of row numbers for list of taxa to include
#' @param vector of row numbers for list of taxa to exclude
#' @return numeric int, max # of taxa that can have genes missing
#' @keywords pangenome, matrix, shared, specific, unique
#' @export 
#' @examples 
#' getunique(pangenome_matrix, taxa_yes, taxa_no)


getunique = function(df, r_yes, r_no) {
  softN = softnum(r_yes)
  shellN = shellnum(r_yes)
  share_yes_strict = which(colSums(df[r_yes,] == 0) == 0) # list of colnums in taxa 'yes' list where genes are present
  share_yes_soft = which(colSums(df[r_yes,] == 0) <= softN) # list of columns in taxa 'yes' list where genes are present (using soft-core threshold)
  share_yes_shell = which(colSums(df[r_yes,] == 0) > softN & colSums(df[r_yes,] == 0) <= shellN)
  share_yes_cloud = which(colSums(df[r_yes,] == 0) > shellN & colSums(df[r_yes,] == 0) <= (length(r_yes) - 1))
  share_yes_atleastone = which(colSums(df[r_yes,] == 0) < length(r_yes)) # list of columns in taxa 'yes' list where present in at least one taxa
  share_no = which(colSums(df[r_no,] > 0) >= 1) # list of colnums in taxa 'no' list where at least 1 gene is present
  uniqueG = list(yes_strict = share_yes_strict[!(share_yes_strict %in% share_no)],
                 yes_strict_ct = length(share_yes_strict[!(share_yes_strict %in% share_no)]),
                 yes_soft = share_yes_soft[!(share_yes_soft %in% share_no)],
                 yes_soft_ct = length(share_yes_soft[!(share_yes_soft %in% share_no)]),
                 yes_shell = share_yes_shell[!(share_yes_shell %in% share_no)],
                 yes_shell_ct = length(share_yes_shell[!(share_yes_shell %in% share_no)]),
                 yes_cloud = share_yes_cloud[!(share_yes_cloud %in% share_no)],
                 yes_cloud_ct = length(share_yes_cloud[!(share_yes_cloud %in% share_no)]),
                 yes_atleastone = share_yes_atleastone[!share_yes_atleastone %in% share_no],
                 yes_atleastone_ct = length(share_yes_atleastone[!share_yes_atleastone %in% share_no])
  )
  
  
  return(uniqueG)
}


#' Interrogate which taxa are missing in a list of gene families
#' @param dataframe formatted by panpretty and NAcheck
#' @param vector of row numbers for list of taxa to include
#' @param vector of gene family names (product of sharedgroups or getunique)
#' @return numeric int, max # of taxa that can have genes missing
#' @keywords pangenome, matrix, shared, specific, unique
#' @export 
#' @examples 
#' getmissing(pangenome_matrix, taxa_yes, genefamily_list)

getmissing = function(pmatrix, taxlist_yes, genefamily_list) {
  if(length(genefamily_list == 1)) {
    taxnames = rownames(pangenome_clean[taxlistMesoAO$r_yes,])
    whichzero = which(pangenome_clean[taxlistMesoAO$r_yes,uniqueMesoAO$yes_soft] == 0)
    taxmissname = taxnames[whichzero]
    newDF = data.frame(genefam=names(genefamily_list),
                       taxmissing=taxmissname,
                       stringsAsFactors=FALSE)
  }
  
  else {
    subset = pmatrix[taxlist_yes, genefamily_list]
    softfams = subset[,which(colSums(subset == 0) > 0)]
    zeros = which(softfams == 0, arr.ind = TRUE)
    newDF = data.frame(genefam=character(length(zeros[,1])),
                       taxamissing=character(length(zeros[,1])),
                       stringsAsFactors= FALSE)
    
    # fill in DF
    for (i in 1:nrow(zeros)) {
      newDF[i,1] = names(softfams)[zeros[i,2]]
      newDF[i,2] = rownames(softfams)[zeros[i,1]]
    }
    
    # compress
    newDF = aggregate(taxamissing ~ genefam, newDF, function(gf) 
      paste(unique(unlist(strsplit(gf, ", "))), collapse = ','))
  }
  
  return(newDF)
  
}

#' Get counts how many ortholog groups are in each COG category
#' @param vector of (character) names of ortholog groups to get functional annotation counts for
#' @param vector of (character) names of COG categories
#' @param dataframe of COG annotations for pangenome
#' @return vector containing # of OF in each category
#' @keywords COG categories, functional enrichment, counts
#' @export 
#' @examples 
#' getcounts(orthologname_list, cogcategories, annotation_df)


getcounts = function(df_sub, categories, thaumtab) {
  result_vector = c()
  for(i in 1:length(categories)) {
    result_vector = c(result_vector, sum(str_detect(thaumtab[df_sub,3], categories[i]), na.rm=TRUE))
    
  }
  result_vector = c(result_vector, sum(is.na(thaumtab[df_sub,3])))
  return(result_vector)
}

